<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brickbreaker</title>
    <!-- Load Google Font for a game-like feel -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a2e; /* Dark blue space background */
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        h1 {
            color: #00f0ff; /* Bright cyan title */
            text-shadow: 0 0 5px #00f0ff, 0 0 10px #00f0ff;
        }

        canvas {
            background: #000;
            border: 4px solid #00f0ff; /* Cyan border */
            box-shadow: 0 0 20px #00f0ff; /* Neon glow */
            border-radius: 8px;
            display: block;
        }

        /* Responsive canvas container */
        .canvas-container {
            width: 90%;
            max-width: 480px; /* Max width for the game */
            margin: 10px auto;
        }

        /* Ensure canvas scales within container */
        #gameCanvas {
            width: 100%;
            height: auto;
            aspect-ratio: 480 / 400; /* Maintain aspect ratio */
        }

        button {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            background-color: #f030a0; /* Bright pink */
            color: #ffffff;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            margin-top: 20px;
            box-shadow: 0 0 10px #f030a0, 0 0 20px #f030a0;
            transition: all 0.2s ease-in-out;
        }

        button:hover {
            background-color: #ff40b0;
            box-shadow: 0 0 15px #f030a0, 0 0 30px #f030a0;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(1px);
        }
    </style>
</head>
<body>

    <h1>BRICKBREAKER</h1>
    
    <!-- Container to help with canvas scaling -->
    <div class="canvas-container">
        <canvas id="gameCanvas" width="480" height="400"></canvas>
    </div>
    
    <button id="startButton">Start Game</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');

        // --- Game Constants ---
        const PADDLE_WIDTH = 80;
        const PADDLE_HEIGHT = 12;
        const PADDLE_MARGIN_BOTTOM = 30;
        const BALL_RADIUS = 8;
        const BRICK_ROW_COUNT = 5;
        const BRICK_COLUMN_COUNT = 7;
        const BRICK_WIDTH = 54;
        const BRICK_HEIGHT = 18;
        const BRICK_PADDING = 10;
        const BRICK_OFFSET_TOP = 30;
        const BRICK_OFFSET_LEFT = 30;

        // --- Game State Variables ---
        let paddle = {
            x: (canvas.width - PADDLE_WIDTH) / 2,
            y: canvas.height - PADDLE_HEIGHT - PADDLE_MARGIN_BOTTOM,
            width: PADDLE_WIDTH,
            height: PADDLE_HEIGHT,
            dx: 0 // Not used in mouse control, but could be for keyboard
        };

        let ball = {
            x: canvas.width / 2,
            y: paddle.y - BALL_RADIUS - 5,
            radius: BALL_RADIUS,
            speed: 4,
            dx: 3,
            dy: -3
        };

        let bricks = [];
        let score = 0;
        let lives = 3;
        let gameRunning = false;
        let gameOver = false;
        let gameWon = false;
        
        // Brick colors
        const brickColors = ["#ff4136", "#ff851b", "#ffdc00", "#2ecc40", "#0074d9"];

        // --- Game Setup ---
        
        /**
         * Initializes or resets the game state.
         */
        function init() {
            score = 0;
            lives = 3;
            gameOver = false;
            gameWon = false;
            resetBallAndPaddle();
            createBricks();
            startButton.textContent = "Start Game";
        }

        /**
         * Fills the bricks array with new bricks.
         */
        function createBricks() {
            bricks = [];
            for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
                bricks[c] = [];
                for (let r = 0; r < BRICK_ROW_COUNT; r++) {
                    const brickX = c * (BRICK_WIDTH + BRICK_PADDING) + BRICK_OFFSET_LEFT;
                    const brickY = r * (BRICK_HEIGHT + BRICK_PADDING) + BRICK_OFFSET_TOP;
                    bricks[c][r] = { x: brickX, y: brickY, status: 1, color: brickColors[r % brickColors.length] };
                }
            }
        }
        
        /**
         * Resets the ball and paddle to their starting positions.
         */
        function resetBallAndPaddle() {
            paddle.x = (canvas.width - PADDLE_WIDTH) / 2;
            ball.x = canvas.width / 2;
            ball.y = paddle.y - BALL_RADIUS - 5;
            // Give a random horizontal start direction
            ball.dx = 3 * (Math.random() > 0.5 ? 1 : -1);
            ball.dy = -3;
        }

        // --- Drawing Functions ---

        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = "#00f0ff"; // Bright cyan ball
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.fillStyle = "#f030a0"; // Bright pink paddle
            ctx.fill();
            ctx.closePath();
        }

        function drawBricks() {
            for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
                for (let r = 0; r < BRICK_ROW_COUNT; r++) {
                    if (bricks[c][r].status === 1) {
                        const brick = bricks[c][r];
                        ctx.beginPath();
                        ctx.rect(brick.x, brick.y, BRICK_WIDTH, BRICK_HEIGHT);
                        ctx.fillStyle = brick.color;
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        function drawScore() {
            ctx.font = '16px "Press Start 2P"';
            ctx.fillStyle = "#ffffff";
            ctx.fillText('Score: ' + score, 8, 20);
        }

        function drawLives() {
            ctx.font = '16px "Press Start 2P"';
            ctx.fillStyle = "#ffffff";
            ctx.fillText('Lives: ' + lives, canvas.width - 100, 20);
        }

        /**
         * Displays a message in the center of the canvas.
         */
        function drawMessage(text, subtext = "") {
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = '24px "Press Start 2P"';
            ctx.fillStyle = "#00f0ff";
            ctx.textAlign = "center";
            ctx.fillText(text, canvas.width / 2, canvas.height / 2 - 20);

            if (subtext) {
                ctx.font = '16px "Press Start 2P"';
                ctx.fillStyle = "#ffffff";
                ctx.fillText(subtext, canvas.width / 2, canvas.height / 2 + 20);
            }
            ctx.textAlign = "left"; // Reset alignment
        }

        // --- Game Logic ---

        function movePaddle(e) {
            // Get the bounding rectangle of the canvas
            const canvasRect = canvas.getBoundingClientRect();
            // Calculate the relative X position of the mouse within the canvas
            // e.clientX is mouse position relative to viewport
            // canvasRect.left is canvas position relative to viewport
            // (canvas.width / canvasRect.width) is the scaling ratio
            let relativeX = (e.clientX - canvasRect.left) * (canvas.width / canvasRect.width);

            if (relativeX > 0 && relativeX < canvas.width) {
                paddle.x = relativeX - paddle.width / 2;
                // Constrain paddle to canvas bounds
                if (paddle.x < 0) {
                    paddle.x = 0;
                }
                if (paddle.x + paddle.width > canvas.width) {
                    paddle.x = canvas.width - paddle.width;
                }
            }
        }

        function moveBall() {
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Wall collision (left/right)
            if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                ball.dx *= -1;
            }
            // Wall collision (top)
            if (ball.y - ball.radius < 0) {
                ball.dy *= -1;
            }
            // Wall collision (bottom)
            if (ball.y + ball.radius > canvas.height) {
                lives--;
                if (lives <= 0) {
                    gameOver = true;
                    gameRunning = false;
                } else {
                    resetBallAndPaddle();
                }
            }
        }

        function checkPaddleCollision() {
            if (
                ball.x > paddle.x &&
                ball.x < paddle.x + paddle.width &&
                ball.y + ball.radius > paddle.y
            ) {
                // Ball hit the paddle
                ball.dy = -ball.speed; // Always bounce up
                
                // Change horizontal direction based on where it hit the paddle
                let hitPoint = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                ball.dx = hitPoint * 4; // Max horizontal speed of 4
            }
        }

        function checkBrickCollision() {
            let allBricksBroken = true;
            for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
                for (let r = 0; r < BRICK_ROW_COUNT; r++) {
                    const brick = bricks[c][r];
                    if (brick.status === 1) {
                        allBricksBroken = false; // Found an active brick
                        if (
                            ball.x > brick.x &&
                            ball.x < brick.x + BRICK_WIDTH &&
                            ball.y > brick.y &&
                            ball.y < brick.y + BRICK_HEIGHT
                        ) {
                            // Ball hit a brick
                            ball.dy *= -1;
                            brick.status = 0;
                            score++;
                        }
                    }
                }
            }
            
            if (allBricksBroken) {
                gameWon = true;
                gameRunning = false;
            }
        }

        // --- Main Game Loop ---

        function update() {
            if (!gameRunning) return;

            moveBall();
            checkPaddleCollision();
            checkBrickCollision();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBricks();
            drawBall();
            drawPaddle();
            drawScore();
            drawLives();

            if (gameOver) {
                drawMessage("GAME OVER", "Click 'Play Again' to restart");
                startButton.textContent = "Play Again";
            } else if (gameWon) {
                drawMessage("YOU WIN!", "Click 'Play Again' to restart");
                startButton.textContent = "Play Again";
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        
        // Handle mouse movement to control the paddle
        // We add this to the document to track mouse even if it leaves the canvas
        document.addEventListener('mousemove', movePaddle);

        // Start/Restart button
        startButton.addEventListener('click', () => {
            if (!gameRunning) {
                init(); // Reset all game variables
                gameRunning = true;
                // If gameLoop isn't already running, start it.
                // This check is a safety, though in this design it's okay.
                if (gameOver || gameWon || lives === 3) {
                     // This is the first time running or a restart
                }
            }
        });

        // --- Start ---
        init(); // Set up the initial state
        gameLoop(); // Start the render loop
        
    </script>
</body>
</html>