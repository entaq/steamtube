<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Tile Puzzle</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
        }
        .puzzle-grid {
            display: grid;
            gap: 8px;
            padding: 8px;
            border-radius: 8px;
            background-color: #374151; /* gray-700 */
        }
        .tile {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            border-radius: 6px;
            background-color: #F3F4F6; /* gray-100 */
            color: #1F2937; /* gray-800 */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            user-select: none;
            aspect-ratio: 1 / 1; /* Ensure tiles are square */
        }
        .tile:hover {
            transform: scale(1.05);
            background-color: #E5E7EB; /* gray-200 */
        }
        .tile.empty {
            background-color: #4B5563; /* gray-600 */
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.05);
            cursor: default;
        }
        .tile.empty:hover {
            transform: none;
            background-color: #4B5563;
        }
        
        /* Responsive grid columns */
        .grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        .grid-cols-5 { grid-template-columns: repeat(5, minmax(0, 1fr)); }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-md mx-auto">
        <h1 class="text-3xl font-bold text-center mb-2">Sliding Tile Puzzle</h1>
        <p id="level-display" class="text-xl text-cyan-400 text-center mb-4">Level 1: 3x3</p>

        <!-- Game Board -->
        <div id="puzzle-container" class="puzzle-grid grid-cols-3 mb-4">
            <!-- Tiles will be generated by JavaScript -->
        </div>

        <!-- Controls -->
        <div class="flex justify-center space-x-4">
            <button id="restart-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all duration-150">
                Restart
            </button>
            <button id="next-level-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all duration-150" style="display: none;">
                Next Level
            </button>
        </div>

        <!-- Win Message -->
        <p id="win-message" class="text-2xl font-bold text-green-400 text-center mt-4" style="display: none;"></p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gridContainer = document.getElementById('puzzle-container');
            const restartBtn = document.getElementById('restart-btn');
            const nextLevelBtn = document.getElementById('next-level-btn');
            const levelDisplay = document.getElementById('level-display');
            const winMessage = document.getElementById('win-message');

            let currentLevel = 1;
            let gridSize = 3;
            let board = [];
            let emptyTile = { row: 0, col: 0 };
            let isGameWon = false;
            const maxLevel = 3; // Max level (5x5)

            function initGame(level) {
                currentLevel = level;
                isGameWon = false;
                
                if (level === 1) gridSize = 3;
                else if (level === 2) gridSize = 4;
                else if (level === 3) gridSize = 5;
                
                levelDisplay.textContent = `Level ${currentLevel}: ${gridSize}x${gridSize}`;
                winMessage.style.display = 'none';
                nextLevelBtn.style.display = 'none';

                // Update grid classes for responsiveness
                gridContainer.className = 'puzzle-grid mb-4'; // Reset classes
                gridContainer.classList.add(`grid-cols-${gridSize}`);


                createSolvableBoard();
                renderBoard();
            }

            function createBoard() {
                // Creates a solved board
                board = [];
                let count = 1;
                for (let r = 0; r < gridSize; r++) {
                    let row = [];
                    for (let c = 0; c < gridSize; c++) {
                        row.push(count++);
                    }
                    board.push(row);
                }
                // Set last tile as empty (0)
                board[gridSize - 1][gridSize - 1] = 0;
                emptyTile = { row: gridSize - 1, col: gridSize - 1 };
            }
            
            function createSolvableBoard() {
                createBoard(); // Start with a solved board
                
                // Shuffle by making a large number of random valid moves
                let shuffles = gridSize * gridSize * 10; // Number of shuffles (Reduced from 20 to 10 for an easier game)
                for (let i = 0; i < shuffles; i++) {
                    const neighbors = getValidNeighbors();
                    const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                    swapTiles(randomNeighbor.row, randomNeighbor.col, emptyTile.row, emptyTile.col, false); // Don't re-render
                }
            }
            
            function getValidNeighbors() {
                const { row, col } = emptyTile;
                const neighbors = [];
                if (row > 0) neighbors.push({ row: row - 1, col: col }); // Up
                if (row < gridSize - 1) neighbors.push({ row: row + 1, col: col }); // Down
                if (col > 0) neighbors.push({ row: row, col: col - 1 }); // Left
                if (col < gridSize - 1) neighbors.push({ row: row, col: col + 1 }); // Right
                return neighbors;
            }

            function renderBoard() {
                gridContainer.innerHTML = '';
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const tileValue = board[r][c];
                        const tile = document.createElement('div');
                        tile.classList.add('tile');
                        
                        if (tileValue === 0) {
                            tile.classList.add('empty');
                        } else {
                            tile.textContent = tileValue;
                        }
                        
                        tile.addEventListener('click', () => handleTileClick(r, c));
                        gridContainer.appendChild(tile);
                    }
                }
            }

            function handleTileClick(row, col) {
                if (isGameWon) return;

                // Check if clicked tile is adjacent to the empty tile
                const isAdjacent = (Math.abs(row - emptyTile.row) + Math.abs(col - emptyTile.col)) === 1;

                if (isAdjacent) {
                    swapTiles(row, col, emptyTile.row, emptyTile.col, true); // Re-render after swap
                    checkWin();
                }
            }

            function swapTiles(r1, c1, r2, c2, shouldRender = true) {
                // Swap in the logical board
                [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
                
                // Update empty tile position
                if (board[r1][c1] === 0) {
                    emptyTile = { row: r1, col: c1 };
                } else {
                    emptyTile = { row: r2, col: c2 };
                }

                if (shouldRender) {
                    renderBoard();
                }
            }

            function checkWin() {
                let count = 1;
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (r === gridSize - 1 && c === gridSize - 1) {
                            if (board[r][c] !== 0) return false;
                        } else {
                            if (board[r][c] !== count) return false;
                        }
                        count++;
                    }
                }

                // If we get here, it's a win
                isGameWon = true;
                winMessage.textContent = `You solved Level ${currentLevel}!`;
                winMessage.style.display = 'block';

                if (currentLevel < maxLevel) {
                    nextLevelBtn.style.display = 'inline-block';
                } else {
                    winMessage.textContent = 'Congratulations! You solved all levels!';
                }
            }
            
            function nextLevel() {
                if (currentLevel < maxLevel) {
                    initGame(currentLevel + 1);
                }
            }

            // Event Listeners
            restartBtn.addEventListener('click', () => initGame(currentLevel));
            nextLevelBtn.addEventListener('click', nextLevel);

            // Start the game!
            initGame(currentLevel);
        });
    </script>
</body>
</html>